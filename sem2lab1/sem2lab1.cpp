// sem2lab1.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
#include "myRect.h" 
#include "myString.h"
#include "bochka.h"
#include <iostream> 

int main()
{
	using namespace std;
	
	 //Задание 1.Объявление класса. Создание экземпляра класса.
	 //Вызов методов класса.
	 //Откройте закладку Class View - (здесь Вы увидите имена методов и
	 //данных - классов Rect и MyString)
	 //Обратите внимание на пиктограммы слева от имен членов класса - они
	 //обозначают спецификатор доступа к каждому члену класса.

	 //Какой конструктор вызывается при создании экземпляра класса?
	 // ANSWER: Конструктор по умолчанию
	 {
		Rect rect;
	 }

	 //1a. Объявите и определите конструктор с параметрами для
	 //инициализации переменных класса. Создайте экземляры класса Rect
	 //с помощью конструктора с параметрами. Если компилятор выдает
	 //ошибку в предыдущем фрагменте, подумайте - чего ему не
	 //хватает? Добейтесь отсутствия ошибок.
	 
	 // ANSWER: Конструктора по умолчанию нет у классов, имеющих хотя бы какой-то свой конструктор
	 
	 //Выполняя задание с самого начала по шагам, определите:
	 //в какой момент происходит вызов конструктора(какого?)?

	 // ANSWER: Происходит после выделения памяти для созданного объекта

	 //Подсказка: учтите, что пользователь Вашего класса может указывать
	 //в качестве параметров любые значения!


	 //1б. При конструировании объекта посредством конструктора без параметров
	 //предусмотрите инициализацию переменных класса, например, нулем

	 //1в. Объявите, определите и вызовите метод класса InflateRect(),
	 //который увеличивает размеры прямоугольника на заданные приращения
	 //(раздвигая стороны от центра - каждую сторону на свое значение).
	 //Подсказка: объявить и определить методы можно не только "вручную",
	 //но и с помощью Wizard-a Class View. Для этого: откройте закладку
	 //ClassView окна проекта, сделайте активным класс Rect и нажмите
	 //правую кнопку мыши - в появившемся контекстном меню выберите
	 //Add/Add Member Function... С помощью появившейся диалоговой панели
	 //"дайте указания" Wizard-у как объявить и определить метод.

	 {
		 Rect* newRect = new Rect(10, 0, 10, 0);

		 newRect->Show();

		 newRect->InflateRect(5, 3, 6, 3);

		 newRect->Show();
	 }

	 {
	 //Задание 2.Перегрузка конструкторов и методов класса.
	 //Конструктор копирования.

	 //2а.Объявите и определите конструктор копирования в классе Rect.
	 //Выполняя задание по шагам, определите, какой
	 //конструктор вызывается при создании r1,r2,r3 и r4?
	 //Чему равны переменные созданных объектов?
		Rect r1;
		Rect r2(1,2,3,4);
		Rect r3 = r1;
		Rect r4(r2);

		r1.Show();
		r2.Show();
		r3.Show();
		r4.Show();

		//2б. Объявите и определите в классе Rect метод InflateRect(),
		//который принимает два аргумента, по умолчанию равных 1, и
		//раздвигает стороны прямоугольника на на заданные приращения.
		//Для каких объектов вызывается функция InflateRect()?
		r1.InflateRect(1, 1);
		r2.InflateRect(2, 2);

		//Какая из функций InflateRect() вызывается в каждом из трех случаев?
		r3.InflateRect(2,2,2,2); // 1-ая
		r3.InflateRect(3,3); // 2-ая
		r3.InflateRect(5); // 2-ая
		r3.InflateRect(); // 2-ая
	 }

	
	 //Задание 3.Спецификаторы доступа. Инкапсуляция.
	 {
		 Rect r;
	 
		//Раскомментируйте следующую строку. Объясните ошибку компилятора
		// ANSWER: Ошибки будет, так как эта переменная объявлена как private
		 
		//int tmp = r.m_left;

		//Введите в класс Rect метод void SetAll(...),
		//который присваивают переменным класса передаваемые
		//значения. Вызовите созданный метод, проверьте корректность.

		 r.SetAll(3, 6, 7, 0);
		 r.Show();

		//Введите в класс Rect парный метод GetAll(...),
		//который "достает" значения private-переменных класса.
		//Вызовите созданный метод, проверьте корректность.
		 r.GetAll();
	 }
	
	
	 //Задание 4.Передача экземпляра класса в качестве параметра
	 //функции. Возвращение объекта класса по значению. Поставив
	 //остановы в конструкторе копирования или выполняя фрагмент
	 //по шагам, определите: в какой момент происходит обращение
	 //к конструктору копирования.
	 //Создайте глобальную функцию
	 // Rect BoundingRect(Rect, Rect);
	 //которая принимает два объекта класса Rect по значению и
	 //возвращает объект класса Rect, который является прямоугольником,
	 //в который вписаны заданные прямоугольники. Как происходит
	 //передача параметров и возвращение объекта класса?

	 //Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	 //может оказаться "ненормализованным", то есть m_left>m_right или/и
	 //m_top>m_bottom

	{

		Rect r1(1,2,3,4), r2(5,6,7,8), r3;
		r3 = BoundingRect(r1, r2); 
  
  
		//Задание 4а. Передача объектов по ссылке. 
		//Создайте глобальную функцию BoundingRect2, которая выполняет ту же 
		//задачу, принимая параметры по ссылке 
		//Вызываются ли конструкторы при передаче параметров? 
  
		// ANSWER: нет
		r3 = BoundingRect2(r1, r2); 
	} 
 

	//Задание 5. Когда вызываются конструкторы и деструкторы. 
	 //Объявите и определите 
	 //явный деструктор класса. Поставьте остановы в  
	 //конструкторе (конструкторах) и деструкторе. Определите: когда для 
	 //каждого из объектов вызывается конструктор, а когда - деструктор? 
	{
		cout << "ex.5" << endl;
		Rect r1; // конструктор
		Rect* pR = new Rect(1,2,1,2);  // конструктор
		{ 
			Rect r2(r1); // конструктор
			Rect arRect[2]; // конструктор

			for (int i=0; i<3; i++) { 
				static Rect r3 (i,i,i,i); // конструктор
				Rect r4(*pR); // конструктор
				Rect r5(i,i,i,i); // конструктор
			}
			// деструктор r3, r4, r5
		}
		// деструктор r2, arRect[0], arRect[1]
		delete pR; // деструктор pR
	} 
	// деструктор r1


	 //Задание 6.Конструктор + деструктор = функциональное 
	 // замыкание. Класс MyString 
	 // Посредством конструктора (конструкторов) и деструктора обеспечьте 
	 //корректные инициализацию и деактивацию объекта  
	 //C помощью остановов определите когда происходит 
	 //захват и освобождение памяти для строки-члена класса 
	 { 
		MyString str("It's my string!"); 
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке. 
		//С помощью cout и метода GetString() распечатайте строку объекта str 
		//Замечание: подумайте, как следует корректно реализовать метод GetString(). 
		cout << str.GetString() << endl;
	 } 
  


	 //6a. Раскомментируйте следующий фрагмент. Подумайте - какие 
	 //неприятности Вас ожидают. Попробуйте исправить положение (как?) 
	{ 
		MyString str1("The first string!"); 
		MyString str2 = str1;  // ANSWER: добавил конструктор копирования
	}  
 
	 //6б. Реализуйте метод SetNewString, который будет заменять строку 
	 // на новую 
	{
		MyString str("It's my string!");
		cout << str.GetString() << endl;

		str.SetNewString("New string");
		cout << str.GetString() << endl;
	}
 
 
	//Задание 7.  Решите с помощью классов следующую задачу: 
	//даны две бочки известного объема. В одной бочке в начальный момент 
	//времени содержится спирт (96%), в другой – вода. 
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки 
	//в другую следующим способом: на каждой итерации 
	//зачерпнули из первой бочки -> вылили во вторую 
	//зачерпнули из второй бочки -> вылили в первую. 
	//Требуется определить номер итерации, на которой концентрация спирта в 
	//первой бочке станет меньше 50%. 
	{
		Bochka spirt(1.0, 96.0); // объем 1л, концентрация 96%
		Bochka water(1.0, 0.0); // объем 1л, концентрация 0%

		int iteration = 0;
		while (spirt.ConcentrationOver50()) {
			spirt.Pereliv(water);
			water.Pereliv(spirt);
			iteration++;
		}

		std::cout << "Number of iterations: " << iteration << std::endl;

	}

	return 0;
}
//end_main

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
