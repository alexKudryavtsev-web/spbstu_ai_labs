// Темы:
// Простое наследование. Виртуальные функции. Абстрактные классы.
// [Битовые поля.]
#include <tchar.h>
#include <iostream>
#include "MyString.cpp"
#include "Shape.cpp"
#include <cstdarg>
#include "MyByte.cpp"
using namespace std;


void numz(int n)
{
	using namespace std;
	cout << "--------------------------------" << endl;
	cout << "Задание " << n << ":" << endl;
}

//Глобальная функция для 9 задания
MyString concat(const vector<const char*>& strs) {
	vector<string> strs_copy;
	for (const auto& str : strs) {
		strs_copy.push_back(str);
	}
	return MyString(strs_copy);
}

int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "rus");

	//Задание 1.Массив объектов класса.
	numz(1);
	{
		//Объявите и проинициализируйте массив ar из объектов
		// типа MyString. 
		MyString str1[3] = { MyString("0_str_0"), MyString("1_str_1"), MyString("2_str_2") };
		str1[0].print();
		str1[1].print();
		str1[2].print();

		//Проверка - печать строк-членов класса


		//Замените размер "3" на "5", не изменяя список инициализаторов.
		MyString str1copy[5]{};
		for (int i = 0; i != 3; ++i) {
			str1copy[i] = str1[i];
		}
		str1copy[0].print();
		str1copy[1].print();
		str1copy[2].print();
		str1copy[3].print();
		str1copy[4].print();

	}


	numz(2);
	//Задание 2.Массив указателей на объекты класса.
	{
		//Объявите и проинициализируйте массив arPtr из трех 
		//указателей на объекты типа MyString.
		MyString* arPtr;


		arPtr = new MyString[3];

		//Печать строк-членов класса

		arPtr[0].setStr("zero");
		arPtr[1].setStr("one");
		arPtr[2].setStr("two");
		for (int i = 0; i != 3; ++i)
		{
			arPtr[i].print();
		}
		delete[] arPtr;
	}


	{
		numz(3);
		//Задание 3.Простое наследование.Аргументы конструктора,
		// передаваемые в базовый класс.

		//Создайте иерархию классов:
		//базовый класс Shape (который описывает любую фигуру)
		//и два производных класса Rect и Circle.
		//Подумайте: какие данные и методы нужно ввести в базовый
		//и производные классы (например, любую фигуру можно сделать
		//цветной => в базовом классе можно ввести переменную, которая
		//будет определять цвет фигуры.
		//Подсказка: для хранения цвета объявите перечисление (RED,GREEN,BLUE...);

		Rect r(Green, 20.0, 20.0);
		double Sr = r.square();
		cout << Sr << endl;

		Circle c(Blue, 10);
		double Sc = c.square();
		cout << Sc << endl;

		Rect rr;
		Circle cc;


		//В конструкторах производных классов предусмотрите передачу
		//параметра-цвета конструктору базового класса.
		//При создании и уничтожении объекта производного типа определите
		//последовательность вызовов конструкторов и деструкторов базового
		//и производного классов
	}




	//////////////////////////////////////////////////////////////////////
	{
		//Задание 4.Виртуальные функции.
		//4а) Модифицируйте классы Shape,Rect и Circle:
		//добавьте в каждый класс public метод void WhereAmI().
		//Реализация каждой функции должна выводить сообщение 
		//следующего вида "Now I am in class Shape(Rect или Circle)".
		//Выполните приведенный фрагмент, объясните результат.

		//4б) Сделайте метод WhereAmI() виртуальным.
		//Снова выполните приведенный фрагмент, объясните разницу.

		{
			numz(4);
			Shape s;
			Rect r;
			Circle c;


			//Метод какого класса вызывается в следующих строчках???
			s.WhereAmI();	//	Shape
			r.WhereAmI();	//	Rect
			c.WhereAmI();	//	Circle



			Shape* pShape = &s;
			Shape* pRect = &r;
			Shape* pCircle = &c;
			pShape->WhereAmI();	//	a)Shape b)Shape
			pRect->WhereAmI();	//	a)Shape b)Rect
			pCircle->WhereAmI(); //	a)Shape b)Circle


			Shape ss;
			Rect rr;
			Circle cc;
			//Заполните ... согласно комментариям
			Shape& rShape = ss; //псевдоним s
			Shape& rRect = rr; //псевдоним r
			Shape& rCircle = cc; //псевдоним c
			ss.WhereAmI();	//вызов посредством rShape	Shape
			rr.WhereAmI();	//вызов посредством	rRect	Rect
			cc.WhereAmI(); //вызов посредством rCircle	Circle

		}

	}
	//////////////////////////////////////////////////////////////////////
	{
		numz(5);
		//Задание 5.Виртуальные деструкторы.
		//Модифицируйте классы:
		//a) введите соответствующие
		// деструкторы (без ключевого слова virtual).
		//Реализация каждого деструктора
		//должна выводить сообщение следующего вида
		// "Now I am in Shape's destructor!" или
		// "Now I am in Rect's destructor!"
		//Выполните фрагмент. Объясните результат.

		// b) Добавьте в объявление деструкторов ключевое слово virtual 
		//Выполните фрагмент.Объясните разницу.


		//Подумайте: какие конструкторы вызываются в следующей строке?
			//Если в разработанных классов каких-то конструкторов
			//не хватает - реализуйте
			//Если Вы считаете, что в приведенном фрагменте чего-то
			//не хватает - добавьте

		Rect r(Blue, 10, 20);
		Shape* ar[] = { new Shape(r), new Rect(r), new Circle(r), new Circle() };
		//Вызовите для каждого элемента массива метод WhereAmI()

		ar[0]->WhereAmI(); //Shape
		ar[1]->WhereAmI();//Rect
		ar[2]->WhereAmI();//Circle
		ar[3]->WhereAmI();//Circle


		delete ar[3];
		delete ar[2];
		delete ar[1];
		delete ar[0];




	}

	//Задание 6*. В чем заключается отличие 1) и 2)
	{
		numz(6);
		Shape* pShapes = new Rect[10];//1)
		for (int i = 0; i != 10; ++i) {
			pShapes[i].WhereAmI();
		}
		cout << endl;
		pShapes->WhereAmI();
		cout << endl;
		Rect* pRects = new Rect[10];//2)
		for (int i = 0; i != 10; ++i) {
			pRects[i].WhereAmI();
		}
		cout << endl;
		pRects->WhereAmI();
		cout << endl;
		//Попробуйте вызвать метод WhereAmI() для каждого элемента обоих массивов -
		//в чем заключается проблема???


		//Освободите динамически захваченную память
		delete[] pRects;
		delete[] pShapes;
	}



	//////////////////////////////////////////////////////////////////////

		//Задание 7.Виртуальные функции и оператор разрешения области видимости. 

	{
		numz(7);
		Rect r(Blue, 100, 200);
		Shape* p = &r;
		p->WhereAmI();//Rect



		//7a Оператор разрешения области видимости.
		//Посредством объекта r и указателя p вызовите виртуальную функцию
		//WhereAmI()класса Shape
		p->Shape::WhereAmI();//Shape
		r.Shape::WhereAmI();//Shape
	}


	//////////////////////////////////////////////////////////////////////

		//Задание 8.Чисто виртуальные функции. 
		//Введите в базовый класс метод void Inflate(int); Подумайте:
		//можно ли реализовать такой метод для базового класса? => как его нужно объявить.
		//Реализуйте этот метод для производных классов.
	{
		numz(8);
		Rect r(Green, 10, 10);
		Shape* p = &r;
		//p->Inflate(5);
		Circle c(Red, 40);
		p = &c;
		//p->Inflate(5);
	}


	{
		//////////////////////////////////////////////////////////////////////
			//Задание 9. Создайте глобальную функцию, которая будет принимать любое
			//количество указателей на строки, а возвращать объект MyString,
			//в котором строка будет конкатенацией параметров
			//Честно, скатал, но скатал максимально понятный для меня код!
		numz(9);
		const char* str1 = "Hello";
		const char* str2 = ", ";
		const char* str3 = "world";
		const char* str4 = "!";

		MyString s = concat({ str1, str2, str3, str4 });

		s.print();

	}
	////////////////////////////////////////////////////////////////////////
	{
		numz(10);
		/*Задание 10. Объединения (union) C++. Битовые поля.
		1.
		Создайте следующие классы для различных представлений значений байта:
		Bin - для двоичного представления
		Hex - для шестнадцатерчного представления
		Oct - для восьмеричного представления.
		Подсказка 1: - для удобства используйте битовые поля.
		Подсказка 2: - конструкторов в таких вспомогательных классах быть не должно,
		так как все они будут членами объединения (union).
		2.
		В каждом классе введите метод Show, который должен выводить значение в
		соответствующем виде
		3.
		Посредством объединения MyByte предоставьте пользователю возможность манипулировать
		одним и тем же значением по-разному:
		а) выводить: десятичное, шестнадцатеричное, восьмеричное, двоичное значение байта
				  а также символ, соответствующий хранимому значению (если есть соответствие);
		б) выводить отдельные (указанные посредством параметра) шестнадцатеричные,
					восьмеричные, двоичные цифры;
		в) изменять отдельные двоичные, восьмеричные или шестнадцатеричные цифры;*/


		MyByte byte(0xff);
		//byte.ShowAll();
		byte.ShowDec();
		byte.ShowBin();
		byte.ShowHex();
		byte.ShowOct();
		byte.ShowSymbol();

		// Вывод отдельных цифр
		cout << "\nДвоичная цифра на позиции 3: ";
		byte.ShowDigit(2, 3);
		cout << endl;

		// Изменение отдельных цифр
		cout << "\nИзменение двоичной цифры на позиции 3 на 0:" << endl;
		byte.SetDigit(2, 3, 0);
		byte.ShowAll();

		cout << "\nИзменение восьмиричной цифры на позиции 2 на 7:" << endl;
		byte.SetDigit(8, 2, 7);
		byte.ShowAll();

		cout << "\nИзменение шеснадцатиричной цифры на позиции 0 на d(13):" << endl;
		byte.SetDigit(16, 0, 13);
		byte.ShowAll();
	}

	return 0;
}